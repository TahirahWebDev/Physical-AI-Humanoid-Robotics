"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[396],{4126:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"chapter_04_Digital_Twin_Simulation","title":"Chapter 4: Digital Twin Simulation (Gazebo + Isaac)","description":"Learning Objectives","source":"@site/docs/chapter_04_Digital_Twin_Simulation.md","sourceDirName":".","slug":"/chapter_04_Digital_Twin_Simulation","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter_04_Digital_Twin_Simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/docs/chapter_04_Digital_Twin_Simulation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: ROS 2 Fundamentals","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter_03_ros2_fundamentals"},"next":{"title":"Chapter 4: Digital Twin Simulation (Gazebo + Isaac)","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapter_05_vla_systems"}}');var r=i(4848),l=i(8453);const a={},t="Chapter 4: Digital Twin Simulation (Gazebo + Isaac)",o={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"4.1 What is Digital Twin Simulation?",id:"41-what-is-digital-twin-simulation",level:2},{value:"4.1.1 Key Benefits",id:"411-key-benefits",level:3},{value:"4.1.2 Simulation Fidelity Levels",id:"412-simulation-fidelity-levels",level:3},{value:"4.2 Introduction to Gazebo",id:"42-introduction-to-gazebo",level:2},{value:"4.2.1 Gazebo Architecture",id:"421-gazebo-architecture",level:3},{value:"4.2.2 Key Features",id:"422-key-features",level:3},{value:"4.2.3 Installation",id:"423-installation",level:3},{value:"4.3 Robot Modeling with URDF",id:"43-robot-modeling-with-urdf",level:2},{value:"4.3.1 URDF Structure",id:"431-urdf-structure",level:3},{value:"4.3.2 Simple Robot Example",id:"432-simple-robot-example",level:3},{value:"4.3.3 URDF Components Explained",id:"433-urdf-components-explained",level:3},{value:"4.3.4 Using Xacro for Modularity",id:"434-using-xacro-for-modularity",level:3},{value:"4.4 Simulation Description Format (SDF)",id:"44-simulation-description-format-sdf",level:2},{value:"4.4.1 URDF vs SDF",id:"441-urdf-vs-sdf",level:3},{value:"4.4.2 Simple SDF World",id:"442-simple-sdf-world",level:3},{value:"4.5 Simulating Sensors",id:"45-simulating-sensors",level:2},{value:"4.5.1 Camera Sensor",id:"451-camera-sensor",level:3},{value:"4.5.2 Depth Camera",id:"452-depth-camera",level:3},{value:"4.5.3 LIDAR (Laser Scan)",id:"453-lidar-laser-scan",level:3},{value:"4.5.4 IMU (Inertial Measurement Unit)",id:"454-imu-inertial-measurement-unit",level:3},{value:"4.5.5 Sensor Noise Modeling",id:"455-sensor-noise-modeling",level:3},{value:"4.6 Gazebo Plugins",id:"46-gazebo-plugins",level:2},{value:"4.6.1 Differential Drive Plugin",id:"461-differential-drive-plugin",level:3},{value:"4.6.2 Joint State Publisher",id:"462-joint-state-publisher",level:3},{value:"4.6.3 Contact Sensor Plugin",id:"463-contact-sensor-plugin",level:3},{value:"4.7 Running Gazebo with ROS 2",id:"47-running-gazebo-with-ros-2",level:2},{value:"4.7.1 Launch File Integration",id:"471-launch-file-integration",level:3},{value:"4.7.2 Running the Simulation",id:"472-running-the-simulation",level:3},{value:"4.8 Introduction to NVIDIA Isaac Sim",id:"48-introduction-to-nvidia-isaac-sim",level:2},{value:"4.8.1 Key Advantages",id:"481-key-advantages",level:3},{value:"4.8.2 Use Cases",id:"482-use-cases",level:3},{value:"4.8.3 System Requirements",id:"483-system-requirements",level:3},{value:"4.8.4 Installation",id:"484-installation",level:3},{value:"4.8.5 Python API Example",id:"485-python-api-example",level:3},{value:"4.9 Gazebo vs Isaac Sim Comparison",id:"49-gazebo-vs-isaac-sim-comparison",level:2},{value:"4.9.1 When to Use Gazebo",id:"491-when-to-use-gazebo",level:3},{value:"4.9.2 When to Use Isaac Sim",id:"492-when-to-use-isaac-sim",level:3},{value:"4.10 Sim-to-Real Transfer",id:"410-sim-to-real-transfer",level:2},{value:"4.10.1 Sources of Sim-to-Real Gap",id:"4101-sources-of-sim-to-real-gap",level:3},{value:"4.10.2 Strategies to Bridge the Gap",id:"4102-strategies-to-bridge-the-gap",level:3},{value:"4.11 Performance Optimization",id:"411-performance-optimization",level:2},{value:"4.11.1 Gazebo Optimization",id:"4111-gazebo-optimization",level:3},{value:"4.11.2 Isaac Sim Optimization",id:"4112-isaac-sim-optimization",level:3},{value:"4.12 Chapter Summary",id:"412-chapter-summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(n){const e={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"chapter-4-digital-twin-simulation-gazebo--isaac",children:"Chapter 4: Digital Twin Simulation (Gazebo + Isaac)"})}),"\n",(0,r.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Understand the concept and benefits of digital twin simulation"}),"\n",(0,r.jsx)(e.li,{children:"Set up and configure Gazebo for robot simulation"}),"\n",(0,r.jsx)(e.li,{children:"Create robot models using URDF and SDF formats"}),"\n",(0,r.jsx)(e.li,{children:"Simulate sensors (cameras, LIDAR, IMU) in Gazebo"}),"\n",(0,r.jsx)(e.li,{children:"Understand NVIDIA Isaac Sim capabilities and use cases"}),"\n",(0,r.jsx)(e.li,{children:"Compare Gazebo and Isaac Sim for different applications"}),"\n",(0,r.jsx)(e.li,{children:"Implement sim-to-real transfer strategies"}),"\n",(0,r.jsx)(e.li,{children:"Debug and optimize simulation performance"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"41-what-is-digital-twin-simulation",children:"4.1 What is Digital Twin Simulation?"}),"\n",(0,r.jsxs)(e.p,{children:["A ",(0,r.jsx)(e.strong,{children:"digital twin"})," is a virtual replica of a physical system that mirrors its behavior, appearance, and dynamics. In robotics, digital twins enable:"]}),"\n",(0,r.jsx)(e.h3,{id:"411-key-benefits",children:"4.1.1 Key Benefits"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"1. Safe Testing"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Test dangerous scenarios without risk"}),"\n",(0,r.jsx)(e.li,{children:"Experiment with extreme conditions"}),"\n",(0,r.jsx)(e.li,{children:"Validate edge cases"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"2. Rapid Iteration"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"No hardware setup time"}),"\n",(0,r.jsx)(e.li,{children:"Instant environment changes"}),"\n",(0,r.jsx)(e.li,{children:"Parallel testing of multiple configurations"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"3. Cost Reduction"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Reduce hardware wear and tear"}),"\n",(0,r.jsx)(e.li,{children:"Minimize prototype iterations"}),"\n",(0,r.jsx)(e.li,{children:"Lower testing infrastructure costs"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"4. Scalability"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Train thousands of agents simultaneously"}),"\n",(0,r.jsx)(e.li,{children:"Test fleet coordination"}),"\n",(0,r.jsx)(e.li,{children:"Simulate large-scale deployments"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"5. Data Generation"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Generate labeled training data"}),"\n",(0,r.jsx)(e.li,{children:"Create diverse scenarios"}),"\n",(0,r.jsx)(e.li,{children:"Augment real-world datasets"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"412-simulation-fidelity-levels",children:"4.1.2 Simulation Fidelity Levels"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Level"}),(0,r.jsx)(e.th,{children:"Physics"}),(0,r.jsx)(e.th,{children:"Graphics"}),(0,r.jsx)(e.th,{children:"Sensors"}),(0,r.jsx)(e.th,{children:"Use Case"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Low"})}),(0,r.jsx)(e.td,{children:"Basic"}),(0,r.jsx)(e.td,{children:"Wireframe"}),(0,r.jsx)(e.td,{children:"Ideal"}),(0,r.jsx)(e.td,{children:"Early prototyping"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Medium"})}),(0,r.jsx)(e.td,{children:"Rigid body"}),(0,r.jsx)(e.td,{children:"Textured"}),(0,r.jsx)(e.td,{children:"Simplified"}),(0,r.jsx)(e.td,{children:"Algorithm development"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"High"})}),(0,r.jsx)(e.td,{children:"Contact, friction"}),(0,r.jsx)(e.td,{children:"Realistic"}),(0,r.jsx)(e.td,{children:"Ray-traced"}),(0,r.jsx)(e.td,{children:"Pre-deployment validation"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Photorealistic"})}),(0,r.jsx)(e.td,{children:"Deformable"}),(0,r.jsx)(e.td,{children:"Path-traced"}),(0,r.jsx)(e.td,{children:"Physical"}),(0,r.jsx)(e.td,{children:"Sim-to-real transfer"})]})]})]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"42-introduction-to-gazebo",children:"4.2 Introduction to Gazebo"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Gazebo"})," is an open-source 3D robotics simulator that integrates tightly with ROS 2."]}),"\n",(0,r.jsx)(e.h3,{id:"421-gazebo-architecture",children:"4.2.1 Gazebo Architecture"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Gazebo Classic (Gazebo 11)"}),": Monolithic architecture"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Single process"}),"\n",(0,r.jsx)(e.li,{children:"Mature, stable"}),"\n",(0,r.jsx)(e.li,{children:"Large plugin ecosystem"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Gazebo (Ignition/Gz)"}),": Modular architecture"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Separate libraries: gz-sim, gz-physics, gz-rendering"}),"\n",(0,r.jsx)(e.li,{children:"Modern design"}),"\n",(0,r.jsx)(e.li,{children:"Better performance"}),"\n",(0,r.jsx)(e.li,{children:"Recommended for new projects"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"422-key-features",children:"4.2.2 Key Features"}),"\n",(0,r.jsxs)(e.p,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Physics Engines"}),": ODE, Bullet, DART, Simbody",(0,r.jsx)(e.br,{}),"\n","\u2705 ",(0,r.jsx)(e.strong,{children:"Rendering"}),": OGRE 1.x/2.x for graphics",(0,r.jsx)(e.br,{}),"\n","\u2705 ",(0,r.jsx)(e.strong,{children:"Sensors"}),": Camera, depth, LIDAR, IMU, GPS, contact",(0,r.jsx)(e.br,{}),"\n","\u2705 ",(0,r.jsx)(e.strong,{children:"Plugins"}),": Extend functionality (custom sensors, controllers)",(0,r.jsx)(e.br,{}),"\n","\u2705 ",(0,r.jsx)(e.strong,{children:"ROS 2 Integration"}),": Native support via ros_gz_bridge",(0,r.jsx)(e.br,{}),"\n","\u2705 ",(0,r.jsx)(e.strong,{children:"Distributed Simulation"}),": Primary/replica for multi-robot"]}),"\n",(0,r.jsx)(e.h3,{id:"423-installation",children:"4.2.3 Installation"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Gazebo (Ignition) Fortress or later"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Ubuntu 22.04 (Humble)\nsudo apt install ros-humble-ros-gz\n\n# Or standalone\nsudo apt install ignition-fortress\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Verify installation"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"gz sim --version\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"43-robot-modeling-with-urdf",children:"4.3 Robot Modeling with URDF"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Unified Robot Description Format (URDF)"})," is an XML format for describing robot kinematics and dynamics."]}),"\n",(0,r.jsx)(e.h3,{id:"431-urdf-structure",children:"4.3.1 URDF Structure"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Basic elements"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"<robot>"}),": Root element"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"<link>"}),": Rigid body with visual, collision, inertial properties"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"<joint>"}),": Connection between two links"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"<gazebo>"}),": Gazebo-specific tags (plugins, sensors)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"432-simple-robot-example",children:"4.3.2 Simple Robot Example"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_robot">\n  \n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.5 0.3 0.2"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.3 0.2"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.2" iyz="0" izz="0.2"/>\n    </inertial>\n  </link>\n  \n  \x3c!-- Wheel Link --\x3e\n  <link name="left_wheel">\n    <visual>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n    </inertial>\n  </link>\n  \n  \x3c!-- Joint connecting base to wheel --\x3e\n  <joint name="left_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="left_wheel"/>\n    <origin xyz="0.15 0.2 -0.1" rpy="1.57 0 0"/>\n    <axis xyz="0 0 1"/>\n  </joint>\n  \n</robot>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"433-urdf-components-explained",children:"4.3.3 URDF Components Explained"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Visual"}),": What you see"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Geometry: box, cylinder, sphere, mesh"}),"\n",(0,r.jsx)(e.li,{children:"Material: color, texture"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Collision"}),": What interacts physically"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Often simpler than visual (performance)"}),"\n",(0,r.jsx)(e.li,{children:"Should enclose visual geometry"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Inertial"}),": Mass and inertia"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Required for physics simulation"}),"\n",(0,r.jsx)(e.li,{children:"Calculated from geometry or measured"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Joint Types"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"fixed"}),": No movement"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"revolute"}),": Rotation with limits"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"continuous"}),": Unlimited rotation (wheels)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"prismatic"}),": Linear motion (sliders)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"floating"}),": 6 DOF (rarely used)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"planar"}),": 2D motion in a plane"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"434-using-xacro-for-modularity",children:"4.3.4 Using Xacro for Modularity"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Xacro"})," extends URDF with macros, variables, and math:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="modular_robot">\n  \n  \x3c!-- Properties --\x3e\n  <xacro:property name="wheel_radius" value="0.1"/>\n  <xacro:property name="wheel_width" value="0.05"/>\n  \n  \x3c!-- Macro for wheel --\x3e\n  <xacro:macro name="wheel" params="name x y">\n    <link name="${name}_wheel">\n      <visual>\n        <geometry>\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\n        </geometry>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\n        </geometry>\n      </collision>\n      <inertial>\n        <mass value="1.0"/>\n        <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\n      </inertial>\n    </link>\n    \n    <joint name="${name}_wheel_joint" type="continuous">\n      <parent link="base_link"/>\n      <child link="${name}_wheel"/>\n      <origin xyz="${x} ${y} 0" rpy="1.57 0 0"/>\n      <axis xyz="0 0 1"/>\n    </joint>\n  </xacro:macro>\n  \n  \x3c!-- Instantiate wheels --\x3e\n  <xacro:wheel name="left_front" x="0.2" y="0.15"/>\n  <xacro:wheel name="right_front" x="0.2" y="-0.15"/>\n  \n</robot>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Convert to URDF"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"xacro my_robot.urdf.xacro > my_robot.urdf\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"44-simulation-description-format-sdf",children:"4.4 Simulation Description Format (SDF)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"SDF"})," is Gazebo's native format, more expressive than URDF."]}),"\n",(0,r.jsx)(e.h3,{id:"441-urdf-vs-sdf",children:"4.4.1 URDF vs SDF"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Feature"}),(0,r.jsx)(e.th,{children:"URDF"}),(0,r.jsx)(e.th,{children:"SDF"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Purpose"})}),(0,r.jsx)(e.td,{children:"Robot description"}),(0,r.jsx)(e.td,{children:"World + robot description"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Scope"})}),(0,r.jsx)(e.td,{children:"Single robot"}),(0,r.jsx)(e.td,{children:"Multiple models, environments"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Sensors"})}),(0,r.jsx)(e.td,{children:"Limited"}),(0,r.jsx)(e.td,{children:"Extensive (camera, LIDAR, IMU, GPS, etc.)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Plugins"})}),(0,r.jsxs)(e.td,{children:["Via ",(0,r.jsx)(e.code,{children:"<gazebo>"})," tags"]}),(0,r.jsxs)(e.td,{children:["Native ",(0,r.jsx)(e.code,{children:"<plugin>"})," tags"]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Physics"})}),(0,r.jsx)(e.td,{children:"Basic"}),(0,r.jsx)(e.td,{children:"Advanced (multiple engines, custom properties)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Nested Models"})}),(0,r.jsx)(e.td,{children:"No"}),(0,r.jsx)(e.td,{children:"Yes"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"442-simple-sdf-world",children:"4.4.2 Simple SDF World"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.9">\n  <world name="simple_world">\n    \n    \x3c!-- Physics --\x3e\n    <physics name="1ms" type="ignored">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n    </physics>\n    \n    \x3c!-- Lighting --\x3e\n    <light type="directional" name="sun">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.5 0.5 -1</direction>\n    </light>\n    \n    \x3c!-- Ground plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n            </plane>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n          </material>\n        </visual>\n      </link>\n    </model>\n    \n    \x3c!-- Include robot model --\x3e\n    <include>\n      <uri>model://my_robot</uri>\n      <pose>0 0 0.5 0 0 0</pose>\n    </include>\n    \n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"45-simulating-sensors",children:"4.5 Simulating Sensors"}),"\n",(0,r.jsx)(e.h3,{id:"451-camera-sensor",children:"4.5.1 Camera Sensor"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"URDF with Gazebo plugin"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="camera_link">\n  <sensor name="camera" type="camera">\n    <camera>\n      <horizontal_fov>1.047</horizontal_fov>\n      <image>\n        <width>640</width>\n        <height>480</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>100</far>\n      </clip>\n    </camera>\n    <always_on>1</always_on>\n    <update_rate>30</update_rate>\n    <visualize>true</visualize>\n    <topic>camera</topic>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"ROS 2 Bridge"})," (publish to ",(0,r.jsx)(e.code,{children:"/camera/image"}),"):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"ros2 run ros_gz_bridge parameter_bridge /camera@sensor_msgs/msg/Image@gz.msgs.Image\n"})}),"\n",(0,r.jsx)(e.h3,{id:"452-depth-camera",children:"4.5.2 Depth Camera"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="depth_camera" type="depth_camera">\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>\n    <image>\n      <width>640</width>\n      <height>480</height>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>10</far>\n    </clip>\n  </camera>\n  <always_on>1</always_on>\n  <update_rate>30</update_rate>\n  <topic>depth_camera</topic>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"453-lidar-laser-scan",children:"4.5.3 LIDAR (Laser Scan)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="lidar" type="gpu_lidar">\n  <lidar>\n    <scan>\n      <horizontal>\n        <samples>360</samples>\n        <resolution>1</resolution>\n        <min_angle>-3.14159</min_angle>\n        <max_angle>3.14159</max_angle>\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.1</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.01</stddev>\n    </noise>\n  </lidar>\n  <always_on>1</always_on>\n  <update_rate>10</update_rate>\n  <topic>lidar</topic>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"454-imu-inertial-measurement-unit",children:"4.5.4 IMU (Inertial Measurement Unit)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="imu" type="imu">\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.01</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.01</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.01</stddev>\n        </noise>\n      </z>\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.1</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.1</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.1</stddev>\n        </noise>\n      </z>\n    </linear_acceleration>\n  </imu>\n  <always_on>1</always_on>\n  <update_rate>100</update_rate>\n  <topic>imu</topic>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"455-sensor-noise-modeling",children:"4.5.5 Sensor Noise Modeling"}),"\n",(0,r.jsx)(e.p,{children:"Adding realistic noise improves sim-to-real transfer:"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Types"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"gaussian"}),": Normal distribution (most common)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"uniform"}),": Random within range"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"salt_pepper"}),": Random outliers (image noise)"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"mean"}),": Bias"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"stddev"}),": Standard deviation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"precision"}),": Inverse variance"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"46-gazebo-plugins",children:"4.6 Gazebo Plugins"}),"\n",(0,r.jsx)(e.p,{children:"Plugins extend Gazebo functionality for custom behaviors."}),"\n",(0,r.jsx)(e.h3,{id:"461-differential-drive-plugin",children:"4.6.1 Differential Drive Plugin"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo>\n  <plugin filename="gz-sim-diff-drive-system" name="gz::sim::systems::DiffDrive">\n    <left_joint>left_wheel_joint</left_joint>\n    <right_joint>right_wheel_joint</right_joint>\n    <wheel_separation>0.4</wheel_separation>\n    <wheel_radius>0.1</wheel_radius>\n    <odom_publish_frequency>50</odom_publish_frequency>\n    <topic>cmd_vel</topic>\n    <odom_topic>odom</odom_topic>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Control from ROS 2"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'ros2 topic pub /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.5}, angular: {z: 0.2}}"\n'})}),"\n",(0,r.jsx)(e.h3,{id:"462-joint-state-publisher",children:"4.6.2 Joint State Publisher"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo>\n  <plugin filename="gz-sim-joint-state-publisher-system" \n          name="gz::sim::systems::JointStatePublisher">\n    <joint_name>left_wheel_joint</joint_name>\n    <joint_name>right_wheel_joint</joint_name>\n    <topic>joint_states</topic>\n    <update_rate>50</update_rate>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"463-contact-sensor-plugin",children:"4.6.3 Contact Sensor Plugin"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="foot_link">\n  <sensor name="foot_contact" type="contact">\n    <contact>\n      <collision>foot_collision</collision>\n    </contact>\n    <update_rate>100</update_rate>\n    <topic>foot_contact</topic>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"47-running-gazebo-with-ros-2",children:"4.7 Running Gazebo with ROS 2"}),"\n",(0,r.jsx)(e.h3,{id:"471-launch-file-integration",children:"4.7.1 Launch File Integration"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    pkg_share = get_package_share_directory('my_robot_gazebo')\n    \n    # Gazebo launch\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            os.path.join(get_package_share_directory('ros_gz_sim'), \n                        'launch', 'gz_sim.launch.py')\n        ]),\n        launch_arguments={'gz_args': '-r empty.sdf'}.items()\n    )\n    \n    # Spawn robot\n    spawn_robot = Node(\n        package='ros_gz_sim',\n        executable='create',\n        arguments=[\n            '-name', 'my_robot',\n            '-topic', '/robot_description',\n            '-z', '0.5'\n        ],\n        output='screen'\n    )\n    \n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[{'robot_description': open('my_robot.urdf').read()}]\n    )\n    \n    # ROS-Gazebo bridge\n    bridge = Node(\n        package='ros_gz_bridge',\n        executable='parameter_bridge',\n        arguments=[\n            '/cmd_vel@geometry_msgs/msg/Twist@gz.msgs.Twist',\n            '/odom@nav_msgs/msg/Odometry@gz.msgs.Odometry',\n            '/camera@sensor_msgs/msg/Image@gz.msgs.Image',\n            '/lidar@sensor_msgs/msg/LaserScan@gz.msgs.LaserScan'\n        ],\n        output='screen'\n    )\n    \n    return LaunchDescription([\n        gazebo,\n        robot_state_publisher,\n        spawn_robot,\n        bridge\n    ])\n"})}),"\n",(0,r.jsx)(e.h3,{id:"472-running-the-simulation",children:"4.7.2 Running the Simulation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'# Launch\nros2 launch my_robot_gazebo simulation.launch.py\n\n# View topics\nros2 topic list\n\n# Control robot\nros2 topic pub /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 1.0}}"\n\n# Visualize in RViz\nrviz2\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"48-introduction-to-nvidia-isaac-sim",children:"4.8 Introduction to NVIDIA Isaac Sim"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"NVIDIA Isaac Sim"})," is a photorealistic robot simulator built on NVIDIA Omniverse."]}),"\n",(0,r.jsx)(e.h3,{id:"481-key-advantages",children:"4.8.1 Key Advantages"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"1. Photorealism"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Real-time ray tracing (RTX)"}),"\n",(0,r.jsx)(e.li,{children:"Physically-based rendering (PBR)"}),"\n",(0,r.jsx)(e.li,{children:"High-fidelity materials and lighting"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"2. Physics Accuracy"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"NVIDIA PhysX 5"}),"\n",(0,r.jsx)(e.li,{children:"GPU-accelerated simulation"}),"\n",(0,r.jsx)(e.li,{children:"Deformable objects, fluids, soft bodies"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"3. AI Integration"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Synthetic data generation (domain randomization)"}),"\n",(0,r.jsx)(e.li,{children:"Isaac Gym for RL training"}),"\n",(0,r.jsx)(e.li,{children:"TensorRT for inference"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"4. Scalability"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Parallel environments (thousands of robots)"}),"\n",(0,r.jsx)(e.li,{children:"Cloud deployment"}),"\n",(0,r.jsx)(e.li,{children:"Distributed simulation"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"482-use-cases",children:"4.8.2 Use Cases"}),"\n",(0,r.jsxs)(e.p,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Perception Training"}),": Generate labeled synthetic data",(0,r.jsx)(e.br,{}),"\n","\u2705 ",(0,r.jsx)(e.strong,{children:"Reinforcement Learning"}),": Train policies in parallel",(0,r.jsx)(e.br,{}),"\n","\u2705 ",(0,r.jsx)(e.strong,{children:"Manipulation"}),": High-fidelity contact simulation",(0,r.jsx)(e.br,{}),"\n","\u2705 ",(0,r.jsx)(e.strong,{children:"Autonomous Vehicles"}),": Photorealistic sensor simulation",(0,r.jsx)(e.br,{}),"\n","\u2705 ",(0,r.jsx)(e.strong,{children:"Warehouse Automation"}),": Fleet coordination testing"]}),"\n",(0,r.jsx)(e.h3,{id:"483-system-requirements",children:"4.8.3 System Requirements"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"GPU"}),": RTX 2070 or higher (RTX 3080+ recommended)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"RAM"}),": 32 GB minimum"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"OS"}),": Ubuntu 20.04/22.04 or Windows 10/11"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Storage"}),": 50 GB"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"484-installation",children:"4.8.4 Installation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Download Isaac Sim from NVIDIA Omniverse\n# Install via Omniverse Launcher\n\n# Or headless (cloud/server)\nwget https://developer.nvidia.com/isaac-sim\n./isaac-sim.sh --headless\n"})}),"\n",(0,r.jsx)(e.h3,{id:"485-python-api-example",children:"4.8.5 Python API Example"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'from omni.isaac.kit import SimulationApp\n\n# Initialize\nsimulation_app = SimulationApp({"headless": False})\n\nfrom omni.isaac.core import World\nfrom omni.isaac.core.objects import DynamicCuboid\nfrom omni.isaac.core.robots import Robot\n\n# Create world\nworld = World()\n\n# Add robot\nrobot = world.scene.add(\n    Robot(\n        prim_path="/World/Robot",\n        name="my_robot",\n        usd_path="path/to/robot.usd"\n    )\n)\n\n# Add object\ncube = world.scene.add(\n    DynamicCuboid(\n        prim_path="/World/Cube",\n        name="cube",\n        position=[1.0, 0, 0.5],\n        size=0.1\n    )\n)\n\n# Reset world\nworld.reset()\n\n# Simulation loop\nfor i in range(1000):\n    world.step(render=True)\n    \n    # Get robot state\n    position, orientation = robot.get_world_pose()\n    print(f"Robot at: {position}")\n\nsimulation_app.close()\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"49-gazebo-vs-isaac-sim-comparison",children:"4.9 Gazebo vs Isaac Sim Comparison"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Feature"}),(0,r.jsx)(e.th,{children:"Gazebo"}),(0,r.jsx)(e.th,{children:"Isaac Sim"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Cost"})}),(0,r.jsx)(e.td,{children:"Free, open-source"}),(0,r.jsx)(e.td,{children:"Free for individuals/research"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Hardware"})}),(0,r.jsx)(e.td,{children:"CPU-friendly"}),(0,r.jsx)(e.td,{children:"Requires RTX GPU"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Physics"})}),(0,r.jsx)(e.td,{children:"ODE, Bullet, DART"}),(0,r.jsx)(e.td,{children:"PhysX 5 (GPU-accelerated)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Graphics"})}),(0,r.jsx)(e.td,{children:"OGRE (good)"}),(0,r.jsx)(e.td,{children:"RTX ray tracing (photorealistic)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"ROS Integration"})}),(0,r.jsx)(e.td,{children:"Native (ROS 1/2)"}),(0,r.jsx)(e.td,{children:"Via Isaac ROS"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Sensors"})}),(0,r.jsx)(e.td,{children:"Standard robotics"}),(0,r.jsx)(e.td,{children:"Photorealistic + standard"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Parallel Sim"})}),(0,r.jsx)(e.td,{children:"Limited"}),(0,r.jsx)(e.td,{children:"Thousands of environments"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Domain Randomization"})}),(0,r.jsx)(e.td,{children:"Manual"}),(0,r.jsx)(e.td,{children:"Built-in tools"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Learning Curve"})}),(0,r.jsx)(e.td,{children:"Moderate"}),(0,r.jsx)(e.td,{children:"Steep"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Community"})}),(0,r.jsx)(e.td,{children:"Large, mature"}),(0,r.jsx)(e.td,{children:"Growing"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Best For"})}),(0,r.jsx)(e.td,{children:"General robotics dev"}),(0,r.jsx)(e.td,{children:"Perception, RL, manipulation"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"491-when-to-use-gazebo",children:"4.9.1 When to Use Gazebo"}),"\n",(0,r.jsxs)(e.p,{children:["\u2705 CPU-only machines",(0,r.jsx)(e.br,{}),"\n","\u2705 Standard mobile robots",(0,r.jsx)(e.br,{}),"\n","\u2705 ROS 2-centric workflows",(0,r.jsx)(e.br,{}),"\n","\u2705 Quick prototyping",(0,r.jsx)(e.br,{}),"\n","\u2705 Community plugins/models"]}),"\n",(0,r.jsx)(e.h3,{id:"492-when-to-use-isaac-sim",children:"4.9.2 When to Use Isaac Sim"}),"\n",(0,r.jsxs)(e.p,{children:["\u2705 RTX GPU available",(0,r.jsx)(e.br,{}),"\n","\u2705 Perception pipeline development",(0,r.jsx)(e.br,{}),"\n","\u2705 Reinforcement learning training",(0,r.jsx)(e.br,{}),"\n","\u2705 High-fidelity manipulation",(0,r.jsx)(e.br,{}),"\n","\u2705 Synthetic data generation",(0,r.jsx)(e.br,{}),"\n","\u2705 Large-scale parallel training"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"410-sim-to-real-transfer",children:"4.10 Sim-to-Real Transfer"}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.strong,{children:"sim-to-real gap"})," is the difference between simulated and real-world performance."]}),"\n",(0,r.jsx)(e.h3,{id:"4101-sources-of-sim-to-real-gap",children:"4.10.1 Sources of Sim-to-Real Gap"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Physics Modeling"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Friction coefficients"}),"\n",(0,r.jsx)(e.li,{children:"Contact dynamics"}),"\n",(0,r.jsx)(e.li,{children:"Deformation and compliance"}),"\n",(0,r.jsx)(e.li,{children:"Actuator delays and backlash"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Sensor Differences"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Noise characteristics"}),"\n",(0,r.jsx)(e.li,{children:"Calibration errors"}),"\n",(0,r.jsx)(e.li,{children:"Lighting variations"}),"\n",(0,r.jsx)(e.li,{children:"Occlusions and reflections"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Environmental Factors"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Surface textures"}),"\n",(0,r.jsx)(e.li,{children:"Object properties"}),"\n",(0,r.jsx)(e.li,{children:"Weather conditions"}),"\n",(0,r.jsx)(e.li,{children:"Human interactions"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"4102-strategies-to-bridge-the-gap",children:"4.10.2 Strategies to Bridge the Gap"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"1. Domain Randomization"}),"\nVary simulation parameters during training:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Lighting (intensity, color, direction)"}),"\n",(0,r.jsx)(e.li,{children:"Textures (floors, walls, objects)"}),"\n",(0,r.jsx)(e.li,{children:"Object properties (mass, friction, size)"}),"\n",(0,r.jsx)(e.li,{children:"Sensor noise (mean, variance)"}),"\n",(0,r.jsx)(e.li,{children:"Actuator dynamics (delays, gains)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Example in Isaac Sim"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"from omni.isaac.core.utils.prims import create_prim\nfrom omni.isaac.core.utils.semantics import add_update_semantics\n\n# Randomize lighting\nlight_intensity = random.uniform(500, 2000)\nlight_color = [random.uniform(0.8, 1.0) for _ in range(3)]\n\n# Randomize object properties\nmass = random.uniform(0.5, 2.0)\nfriction = random.uniform(0.3, 0.9)\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"2. System Identification"}),"\nMeasure real robot parameters:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# Measure friction coefficient\nmeasured_friction = measure_friction_coefficient(robot)\n\n# Update simulation\nset_friction_coefficient(sim_robot, measured_friction)\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"3. Sim-to-Real Adaptation"}),"\nFine-tune in real world:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Collect small real-world dataset"}),"\n",(0,r.jsx)(e.li,{children:"Fine-tune sim-trained policy"}),"\n",(0,r.jsx)(e.li,{children:"Online adaptation during deployment"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"4. Robust Control"}),"\nDesign controllers tolerant to model errors:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Adaptive control"}),"\n",(0,r.jsx)(e.li,{children:"Model predictive control with uncertainty"}),"\n",(0,r.jsx)(e.li,{children:"Robust optimization"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"5. Realistic Sensor Modeling"}),"\nAdd noise that matches real sensors:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<noise type="gaussian">\n  <mean>0.0</mean>\n  <stddev>0.02</stddev>  \x3c!-- Measured from real sensor --\x3e\n</noise>\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"411-performance-optimization",children:"4.11 Performance Optimization"}),"\n",(0,r.jsx)(e.h3,{id:"4111-gazebo-optimization",children:"4.11.1 Gazebo Optimization"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Reduce Visual Complexity"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Use simple collision meshes"}),"\n",(0,r.jsx)(e.li,{children:"Lower polygon count for visuals"}),"\n",(0,r.jsx)(e.li,{children:"Disable shadows if not needed"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Physics Tuning"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<physics name="fast" type="ode">\n  <max_step_size>0.01</max_step_size>  \x3c!-- Larger = faster --\x3e\n  <real_time_factor>1.0</real_time_factor>\n  <max_contacts>10</max_contacts>  \x3c!-- Fewer = faster --\x3e\n</physics>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Sensor Update Rates"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Camera: 10-30 Hz (not 60 Hz unless needed)"}),"\n",(0,r.jsx)(e.li,{children:"LIDAR: 10-20 Hz"}),"\n",(0,r.jsx)(e.li,{children:"IMU: 100-200 Hz"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Parallel Simulation"}),":\nUse multiple Gazebo instances for different scenarios."]}),"\n",(0,r.jsx)(e.h3,{id:"4112-isaac-sim-optimization",children:"4.11.2 Isaac Sim Optimization"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use GPU Acceleration"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'from omni.isaac.core.utils.extensions import enable_extension\nenable_extension("omni.isaac.core_nodes")\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Headless Mode"})," (no GUI):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'simulation_app = SimulationApp({"headless": True})\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Reduce Rendering Quality"})," (if graphics not critical):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'simulation_app.update_app_setting("rtx/post/aa/op", 0)  # Disable anti-aliasing\nsimulation_app.update_app_setting("rtx/reflections/enabled", False)\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"412-chapter-summary",children:"4.12 Chapter Summary"}),"\n",(0,r.jsx)(e.p,{children:"Digital twin simulation enables safe, rapid, cost-effective robot development through virtual replicas. Gazebo is an open-source simulator with tight ROS 2 integration, supporting various physics engines and sensors. NVIDIA Isaac Sim offers photorealistic graphics and GPU-accelerated physics for perception and reinforcement learning applications."}),"\n",(0,r.jsx)(e.p,{children:"Robot models are described using URDF (ROS standard) or SDF (Gazebo native). URDF defines links, joints, and basic properties, while Xacro adds modularity through macros. SDF extends capabilities with advanced sensors, plugins, and world descriptions."}),"\n",(0,r.jsx)(e.p,{children:"Sensor simulation includes cameras, depth sensors, LIDAR, and IMUs with realistic noise modeling. Gazebo plugins enable differential drive, joint state publishing, and contact sensing. ROS 2 integration uses ros_gz_bridge to connect simulation topics with robot software."}),"\n",(0,r.jsx)(e.p,{children:"Isaac Sim excels in photorealism, parallel simulation, and AI integration, requiring RTX GPUs. Gazebo is CPU-friendly and better for general robotics development. Choose based on hardware, use case, and required fidelity."}),"\n",(0,r.jsx)(e.p,{children:"The sim-to-real gap arises from physics modeling, sensor differences, and environmental factors. Bridge it through domain randomization, system identification, sim-to-real adaptation, robust control, and realistic sensor modeling. Optimize performance by tuning physics parameters, reducing visual complexity, and leveraging GPU acceleration."}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(e.p,{children:["\u2705 Digital twins enable safe, scalable, cost-effective robot testing",(0,r.jsx)(e.br,{}),"\n","\u2705 Gazebo: Open-source, ROS 2-native, CPU-friendly, mature ecosystem",(0,r.jsx)(e.br,{}),"\n","\u2705 Isaac Sim: Photorealistic, GPU-accelerated, AI-focused, requires RTX",(0,r.jsx)(e.br,{}),"\n","\u2705 URDF describes robot kinematics; SDF adds sensors and world modeling",(0,r.jsx)(e.br,{}),"\n","\u2705 Xacro provides modularity through macros and variables",(0,r.jsx)(e.br,{}),"\n","\u2705 Simulate cameras, depth, LIDAR, IMU with realistic noise",(0,r.jsx)(e.br,{}),"\n","\u2705 Gazebo plugins enable custom behaviors (diff drive, joint states)",(0,r.jsx)(e.br,{}),"\n","\u2705 ros_gz_bridge connects Gazebo topics to ROS 2",(0,r.jsx)(e.br,{}),"\n","\u2705 Sim-to-real gap: Address with domain randomization, system ID, adaptation",(0,r.jsx)(e.br,{}),"\n","\u2705 Optimize: Tune physics, reduce complexity, use GPU acceleration"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Gazebo Documentation"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Gazebo (Ignition) Tutorials (gazebosim.org/docs)"}),"\n",(0,r.jsx)(e.li,{children:"ROS 2 + Gazebo Integration Guide"}),"\n",(0,r.jsx)(e.li,{children:"SDF Specification (sdformat.org)"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Isaac Sim"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"NVIDIA Isaac Sim Documentation"}),"\n",(0,r.jsx)(e.li,{children:"Isaac ROS Documentation"}),"\n",(0,r.jsx)(e.li,{children:"Omniverse USD Documentation"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Books & Papers"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:'"Learning Dexterous Manipulation from Suboptimal Demonstrations" (OpenAI)'}),"\n",(0,r.jsx)(e.li,{children:'"Sim-to-Real Transfer of Robotic Control with Dynamics Randomization" (Peng et al.)'}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Community"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Gazebo Community (community.gazebosim.org)"}),"\n",(0,r.jsx)(e.li,{children:"NVIDIA Isaac Forums"}),"\n",(0,r.jsx)(e.li,{children:"ROS Discourse Simulation Category"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Next Chapter"}),": Vision-Language-Action Systems \u2013 We'll explore how modern AI models enable robots to understand natural language commands and perform complex tasks through multimodal perception."]})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>t});var s=i(6540);const r={},l=s.createContext(r);function a(n){const e=s.useContext(l);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),s.createElement(l.Provider,{value:e},n.children)}}}]);